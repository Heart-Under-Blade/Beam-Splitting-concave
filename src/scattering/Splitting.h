#pragma once

#include "Beam.h"

#define EPS_ORTO_FACET 0.0001

enum class IncidenceType
{
	Regular,
	Normal,
	TotalReflection
};

/**
 * @brief Reflected and refracted beams generated by splitting
 */
template <class T>
class BeamPair
{
public:
	T internal;
	T external;
};

/**
 * @brief Defines a type of incidence and beam directions
 */
class Splitting
{
public:
	Splitting(const complex &ri);

	void ComputeSplittingParams(const Vector3f &dir, const Vector3f &normal,
								bool isInside);

	void ComputeSplittingParams(const Point3f &dir, const Point3f &normal);

	IncidenceType GetIncidenceType() const;
	void SetBeams(const Polygon &beamShape);

	double ComputeEffectiveReRi(double cosA2) const;

	void ComputeReflectedDirection(Vector3f &dir) const
	{
		dir = r - facetNormal;
		Point3f::Normalize(dir); // REF, OPT: нужно ли это нормализовать всегда?
	}

	void ComputeRefractedDirection(Vector3f &dir) const
	{
		dir = r/sqrt(s) + facetNormal;
		Point3f::Normalize(dir); // REF, OPT: нужно ли это нормализовать всегда?
	}

	complex GetRi() const;

	Point3f ChangeBeamDirection(const Vector3f &oldDir, const Vector3f &normal,
								bool isInOld, bool isInNew);

	Point3f ChangeBeamDirectionConvex(const Vector3f &oldDir,
									  const Vector3f &normal, bool isIn);
public:
	BeamPair<Beam> beams;
	complex m_ri;	///< Refractive index of a Particle

	double cosA;			///< Angle of incidence
	double cosA2;			// cosA^2
	double reRiEff;			///< Real part of effective refractive index
	Vector3f facetNormal;	///< Normal of current facet
	double s;
	Vector3f r;
	IncidenceType type;

private:
	double m_cRi0;
	double m_cRi1;
	double m_cRi2;

	void RefractIn(const Vector3f &r, const Vector3f &normal,
				   Vector3f &newDir);

	void ReflectExternal(const Vector3f &oldDir, const Vector3f &normal,
						 Vector3f &newDir);

	void ReflectInternal(const Vector3f &oldDir, const Vector3f &normal,
						 Vector3f &newDir);
	void RefractOut(const Vector3f &oldDir, const Vector3f &normal,
					Vector3f &newDir);
};


class FacetChecker
{
public:
	virtual bool IsVisibleFacet(Facet *facet, const Beam &beam, bool isBeamInside)
	{
		if (facet->index != beam.facet->index)
		{
			const Point3f &facetNormal = facet->normal[isBeamInside];
			double cosA = Point3f::DotProduct(facetNormal, beam.direction);
			return cosA > FLT_EPSILON;
		}
		else
		{
			return false;
		}
	}
};

class LightFacetChecker : public FacetChecker
{
public:
};

class BeamFacetChecker : public FacetChecker
{
public:
	bool IsVisibleFacet(Facet *facet, const Beam &beam, bool isBeamInside) override
	{
		if (FacetChecker::IsVisibleFacet(facet, beam, isBeamInside))
		{
			Point3f vectorFromBeamToFacet = facet->center - beam.facet->center;
			const Point3f &beamNormal = beam.facet->normal[!isBeamInside];
			double cosBF = Point3f::DotProduct(beamNormal, vectorFromBeamToFacet);
			return (cosBF >= EPS_ORTO_FACET);
		}
		else
		{
			return false;
		}
	}
};
